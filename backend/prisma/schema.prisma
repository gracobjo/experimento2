generator client {
  provider = "prisma-client-js"
}

/// @seed="ts-node prisma/seed.ts"

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                    String   @id @default(uuid())
  name                  String
  email                 String   @unique
  password              String
  role                  Role     @default(CLIENTE)
  resetPasswordToken   String?
  resetPasswordExpires DateTime?
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  appointmentsAsLawyer Appointment[]
  client                Client?
  documents             Document[]    @relation("UserDocuments")
  expedientesAsLawyer  Expediente[]  @relation("LawyerExpedientes")
  lawyer                Lawyer?
  receivedMessages      ChatMessage[] @relation("ReceivedMessages")
  sentMessages          ChatMessage[] @relation("SentMessages")
  assignedTasks         Task[]        @relation("AssignedTasks")
  createdTasks          Task[]        @relation("CreatedTasks")
  facturasEmitidas      Invoice[]     @relation("EmisorFacturas")
  facturasRecibidas     Invoice[]     @relation("ReceptorFacturas")
  layouts               Layout[]
  teleassistanceSessions TeleassistanceSession[] @relation("UserTeleassistanceSessions")
  assistantSessions     TeleassistanceSession[] @relation("AssistantTeleassistanceSessions")
  teleassistanceMessages TeleassistanceMessage[]
  assignedVisitorAppointments VisitorAppointment[] @relation("AssignedVisitorAppointments")
  notes                 Note[]      @relation("UserNotes")
  refreshTokens         RefreshToken[]
  blacklistedTokens     BlacklistedToken[]
  invoiceAuditHistory   InvoiceAuditHistory[]
  emailLogs             EmailLog[]
  chatbotConversations ChatbotConversation[]
}

model Client {
  id           String        @id @default(uuid())
  userId       String        @unique
  dni          String        @unique
  phone        String?
  address      String?
  createdAt    DateTime      @default(now())
  appointments Appointment[]
  user         User          @relation(fields: [userId], references: [id])
  expedientes  Expediente[]
  tasks        Task[]
  provisionFondos ProvisionFondos[]
}

model Lawyer {
  id        String   @id @default(uuid())
  userId    String   @unique
  colegiado String   @unique
  phone     String?
  address   String?
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])
}

model Expediente {
  id          String     @id @default(uuid())
  title       String
  description String?
  status      Status
  clientId    String
  lawyerId    String
  createdAt   DateTime   @default(now())
  documents   Document[]
  client      Client     @relation(fields: [clientId], references: [id])
  lawyer      User       @relation("LawyerExpedientes", fields: [lawyerId], references: [id])
  tasks       Task[]
  facturas    Invoice[]
  provisionFondos ProvisionFondos[]
  notes       Note[]
}

model Document {
  id             String     @id @default(uuid())
  expedienteId   String
  filename       String
  fileUrl        String
  uploadedAt     DateTime   @default(now())
  description    String?
  fileSize       Int
  mimeType       String
  originalName   String
  uploadedBy     String
  metadata       Json?      // Metadatos adicionales (Cloudinary, S3, etc.)
  expediente     Expediente @relation(fields: [expedienteId], references: [id])
  uploadedByUser User       @relation("UserDocuments", fields: [uploadedBy], references: [id])
}

model Appointment {
  id       String   @id @default(uuid())
  clientId String
  lawyerId String
  date     DateTime
  location String?
  notes    String?
  status   String   @default("PENDIENTE") // PENDIENTE, CONFIRMADA, CANCELADA, COMPLETADA
  client   Client   @relation(fields: [clientId], references: [id])
  lawyer   User     @relation(fields: [lawyerId], references: [id])
}

model VisitorAppointment {
  id                String   @id @default(uuid())
  fullName          String
  age               Int
  phone             String
  email             String
  consultationReason String
  preferredDate     DateTime
  alternativeDate   DateTime?
  consultationType  String
  notes             String?
  location          String?
  status            String   @default("PENDIENTE") // PENDIENTE, CONFIRMADA, CANCELADA, COMPLETADA
  assignedLawyerId  String?
  confirmedDate     DateTime?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  assignedLawyer    User?    @relation("AssignedVisitorAppointments", fields: [assignedLawyerId], references: [id])
  chatbotConversations ChatbotConversation[]
  emailLogs         EmailLog[]

  @@map("visitor_appointments")
}

model ChatMessage {
  id         String   @id @default(uuid())
  content    String
  senderId   String
  receiverId String
  createdAt  DateTime @default(now())
  read       Boolean  @default(false)
  receiver   User     @relation("ReceivedMessages", fields: [receiverId], references: [id], onDelete: Cascade)
  sender     User     @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)

  @@map("chat_messages")
}

model ChatBotMessage {
  id        String   @id @default(uuid())
  sender    Sender
  sessionId String
  message   String
  createdAt DateTime @default(now())

  @@map("chat_bot_messages")
}

// Nuevo modelo para persistir conversaciones del chatbot
model ChatbotConversation {
  id                String   @id @default(uuid())
  sessionId         String   @unique
  userId            String?  // ID del usuario si está autenticado
  userEmail         String?  // Email del usuario si lo proporciona
  userPhone         String?  // Teléfono del usuario si lo proporciona
  conversationType  String   // "appointment", "general", "support"
  status            String   @default("ACTIVE") // "ACTIVE", "COMPLETED", "ABANDONED"
  startedAt         DateTime @default(now())
  completedAt       DateTime?
  totalMessages     Int      @default(0)
  userMessages      Int      @default(0)
  botMessages       Int      @default(0)
  lastActivity      DateTime @updatedAt
  language          String   @default("es")
  userAgent         String?  // Información del navegador
  ipAddress         String?  // IP del usuario
  metadata          Json?    // Datos adicionales (ubicación, dispositivo, etc.)

  // Relaciones
  messages          ChatbotMessageDetail[]
  appointment       VisitorAppointment? @relation(fields: [appointmentId], references: [id])
  appointmentId     String?
  user              User?    @relation(fields: [userId], references: [id])

  @@map("chatbot_conversations")
}

// Nuevo modelo para mensajes detallados del chatbot
model ChatbotMessageDetail {
  id                String   @id @default(uuid())
  conversationId    String
  messageType       String   // "user_input", "bot_response", "system_message"
  content           String   // Contenido del mensaje
  intent            String?  // Intención detectada
  confidence        Float?   // Nivel de confianza de la detección
  entities          Json?    // Entidades extraídas (nombres, fechas, etc.)
  sentiment         String?  // "positive", "negative", "neutral"
  timestamp         DateTime @default(now())
  processingTime    Int?     // Tiempo de procesamiento en ms
  error             String?  // Error si ocurrió alguno

  // Relaciones
  conversation      ChatbotConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@map("chatbot_message_details")
}

// Nuevo modelo para auditoría de emails
model EmailLog {
  id                String   @id @default(uuid())
  recipient         String   // Email del destinatario
  subject           String   // Asunto del email
  template          String   // Tipo de plantilla usada
  status            String   // "SENT", "DELIVERED", "FAILED", "BOUNCED"
  sentAt            DateTime @default(now())
  deliveredAt       DateTime?
  failedAt          DateTime?
  error             String?  // Mensaje de error si falla
  retryCount        Int      @default(0)
  maxRetries        Int      @default(3)
  emailProvider     String?  // Proveedor de email usado
  messageId         String?  // ID del mensaje del proveedor
  metadata          Json?    // Datos adicionales (headers, attachments, etc.)

  // Relaciones opcionales
  appointmentId     String?  // Si está relacionado con una cita
  appointment       VisitorAppointment? @relation(fields: [appointmentId], references: [id])
  userId            String?  // Si está relacionado con un usuario
  user              User?    @relation(fields: [userId], references: [id])

  @@map("email_logs")
}

// Nuevo modelo para analytics del chatbot
model ChatbotAnalytics {
  id                String   @id @default(uuid())
  date              DateTime @default(now())
  totalConversations Int     @default(0)
  completedConversations Int @default(0)
  abandonedConversations Int @default(0)
  totalMessages     Int      @default(0)
  averageMessagesPerConversation Float @default(0)
  appointmentBookings Int    @default(0)
  conversionRate    Float    @default(0) // % de conversaciones que resultan en citas
  averageResponseTime Float  @default(0) // Tiempo promedio de respuesta del bot
  topIntents        Json?    // Intenciones más comunes
  topEntities       Json?    // Entidades más extraídas
  userSatisfaction  Float?   // Puntuación de satisfacción del usuario
  errorRate         Float    @default(0) // % de errores
  languageDistribution Json? // Distribución por idiomas
  deviceDistribution Json?   // Distribución por dispositivos

  @@map("chatbot_analytics")
}

model Task {
  id             String      @id @default(uuid())
  title          String
  description    String?
  dueDate        DateTime?
  priority       String      @default("MEDIA")
  status         String      @default("PENDIENTE")
  expedienteId   String?
  clientId       String?
  assignedTo     String?
  createdBy      String
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt
  assignedToUser User?       @relation("AssignedTasks", fields: [assignedTo], references: [id])
  client         Client?     @relation(fields: [clientId], references: [id])
  createdByUser  User        @relation("CreatedTasks", fields: [createdBy], references: [id], onDelete: Cascade)
  expediente     Expediente? @relation(fields: [expedienteId], references: [id])

  @@map("tasks")
}

model Parametro {
  id        String   @id @default(uuid())
  clave     String   @unique
  valor     String
  etiqueta  String
  tipo      String   // 'string', 'number', 'email', 'image', etc.
  updatedAt DateTime @updatedAt
}

enum Role {
  ADMIN
  ABOGADO
  CLIENTE
}

enum Status {
  ABIERTO
  EN_PROCESO
  CERRADO
}

enum InvoiceStatus {
  BORRADOR
  EMITIDA
  ENVIADA
  NOTIFICADA
  ACEPTADA
  RECHAZADA
  ANULADA
}

enum Sender {
  USER
  BOT
}

model Invoice {
  id                String        @id @default(uuid())
  numeroFactura     String        @unique
  fechaFactura      DateTime
  tipoFactura       String        // F=Completa, R=Rectificativa
  emisorId          String        // User (abogado/despacho)
  receptorId        String        // User (cliente)
  expedienteId      String?       // Relación opcional con Expediente
  importeTotal      Float
  baseImponible     Float
  cuotaIVA          Float
  tipoIVA           Float
  descuento         Float?        // Porcentaje de descuento
  retencion         Float?        // Porcentaje de retención
  aplicarIVA        Boolean       @default(true) // Si se debe aplicar IVA
  tipoImpuesto      String?       // Tipo de impuesto: 'iva' o 'retencion'
  regimenIvaEmisor  String
  claveOperacion    String        // Por defecto '01'
  metodoPago        String
  fechaOperacion    DateTime
  xml               String?       // XML Facturae generado
  xmlFirmado        String?       // XML firmado digitalmente
  estado            String        @default("borrador") // borrador, emitida, enviada, notificada, aceptada, rechazada, anulada
  motivoAnulacion    String?       // Motivo de anulación (nullable)
  selloTiempo       DateTime?     // Sello de tiempo TSA
  externalId        String?       // ID en sistema externo (AEAT, FACE, etc.)
  sistemaEnvio      String?       // Sistema al que se envió (AEAT, FACE, etc.)
  fechaEnvio        DateTime?     // Fecha de envío a sistema externo
  paymentDate       DateTime?     // Fecha de pago de la factura
  // Campos para facturas rectificativas
  facturaOriginalId String?       // ID de la factura original (para rectificativas)
  tipoRectificacion String?       // R1, R2, R3, R4 (para rectificativas)
  motivoRectificacion String?     // Motivo de la rectificación
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  emisor            User          @relation("EmisorFacturas", fields: [emisorId], references: [id])
  receptor          User          @relation("ReceptorFacturas", fields: [receptorId], references: [id])
  expediente        Expediente?   @relation(fields: [expedienteId], references: [id])
  items             InvoiceItem[]
  provisionFondos    ProvisionFondos[]
  auditHistory      InvoiceAuditHistory[]
  // Relación con factura original (para rectificativas)
  facturaOriginal   Invoice?      @relation("FacturaRectificativa", fields: [facturaOriginalId], references: [id])
  facturasRectificativas Invoice[] @relation("FacturaRectificativa")
}

model InvoiceItem {
  id          String   @id @default(uuid())
  invoiceId   String
  description String
  quantity    Int
  unitPrice   Float
  total       Float
  invoice     Invoice  @relation(fields: [invoiceId], references: [id])
}

model ProvisionFondos {
  id           String     @id @default(uuid())
  clientId     String
  expedienteId String?
  invoiceId    String?
  amount       Float
  date         DateTime   @default(now())
  description  String?
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  client       Client     @relation(fields: [clientId], references: [id])
  expediente   Expediente? @relation(fields: [expedienteId], references: [id])
  invoice      Invoice?   @relation(fields: [invoiceId], references: [id])
}

model Layout {
  id            String   @id @default(uuid())
  name          String
  slug          String   @unique // 'home', 'about', etc.
  components    Json     // Array de componentes serializado
  version       Int      @default(1)
  isActive      Boolean  @default(false)
  createdBy     String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  createdByUser User     @relation(fields: [createdBy], references: [id])

  @@map("layouts")
}

model Contact {
  id        String   @id @default(uuid())
  nombre    String
  email     String
  telefono  String?
  asunto    String
  mensaje   String
  ip        String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Note {
  id           String     @id @default(uuid())
  expedienteId String
  title        String
  content      String
  authorId     String
  isPrivate    Boolean    @default(false) // Si es true, solo visible para abogados
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  
  expediente   Expediente @relation(fields: [expedienteId], references: [id], onDelete: Cascade)
  author       User       @relation("UserNotes", fields: [authorId], references: [id], onDelete: Cascade)
}

// Configuración de menús y elementos del sitio
model MenuConfig {
  id          String   @id @default(uuid())
  name        String   // 'main-nav', 'sidebar-admin', 'sidebar-lawyer', 'sidebar-client'
  role        Role     // Para qué rol es el menú
  orientation String   @default("horizontal") // 'horizontal', 'vertical'
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  items       MenuItem[]
}

model MenuItem {
  id          String     @id @default(uuid())
  menuConfigId String
  label       String     // Texto visible del enlace
  url         String     // URL de destino
  icon        String?    // Icono (emoji o clase CSS)
  order       Int        @default(0)
  isVisible   Boolean    @default(true)
  isExternal  Boolean    @default(false) // Si es enlace externo
  parentId    String?    // Para submenús
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  menuConfig  MenuConfig @relation(fields: [menuConfigId], references: [id], onDelete: Cascade)
  parent      MenuItem?  @relation("MenuItemParent", fields: [parentId], references: [id])
  children    MenuItem[] @relation("MenuItemParent")
}

model SiteConfig {
  id          String   @id @default(uuid())
  key         String   @unique // 'site_name', 'logo_url', 'favicon_url', 'primary_color', etc.
  value       String
  type        String   @default("string") // 'string', 'image', 'color', 'boolean', 'json'
  category    String   @default("general") // 'branding', 'layout', 'contact', 'social'
  description String?
  isPublic    Boolean  @default(false) // Si se puede acceder sin autenticación
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model TeleassistanceSession {
  id          String   @id @default(cuid())
  userId      String
  assistantId String
  issueType   String   // AUTOFIRMA, CERTIFICADO_DIGITAL, SEDES, etc.
  description String
  remoteTool  String?  // REMOTELY_ANYWHERE, TEAMVIEWER, etc.
  status      String   @default("PENDING") // PENDING, ACTIVE, COMPLETED, CANCELLED
  sessionCode String   @unique
  resolution  String?
  notes       String?
  startedAt   DateTime?
  completedAt DateTime?
  duration    Int?     // duración en minutos
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user      User @relation("UserTeleassistanceSessions", fields: [userId], references: [id])
  assistant User @relation("AssistantTeleassistanceSessions", fields: [assistantId], references: [id])
  messages  TeleassistanceMessage[]

  @@map("teleassistance_sessions")
}

model TeleassistanceMessage {
  id          String   @id @default(cuid())
  sessionId   String
  senderId    String
  content     String
  messageType String   @default("TEXT") // TEXT, INSTRUCTION, SYSTEM
  createdAt   DateTime @default(now())

  session TeleassistanceSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sender  User                   @relation(fields: [senderId], references: [id])

  @@map("teleassistance_messages")
}

model RefreshToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  isRevoked Boolean  @default(false)
  userAgent String?
  ipAddress String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
}

model BlacklistedToken {
  id           String   @id @default(uuid())
  tokenHash    String   @unique
  userId       String
  expiresAt    DateTime
  blacklistedAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([tokenHash])
  @@index([userId])
  @@index([expiresAt])
}

model InvoiceAuditHistory {
  id          String   @id @default(uuid())
  invoiceId   String
  userId      String   // Usuario que realizó el cambio
  action      String   // 'created', 'updated', 'deleted', 'status_changed'
  fieldName   String?  // Campo específico que cambió
  oldValue    String?  // Valor anterior
  newValue    String?  // Nuevo valor
  description String   // Descripción del cambio
  ipAddress   String?  // IP del usuario
  userAgent   String?  // User agent del navegador
  createdAt   DateTime @default(now())
  
  invoice     Invoice  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id])
  
  @@index([invoiceId])
  @@index([userId])
  @@index([createdAt])
}
